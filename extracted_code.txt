File: /home/samk13/INVENIO/issues/invenio-rdm-records/invenio_rdm_records/records/api.py

class RDMRecord(CommonFieldsMixin, Record):
    """RDM Record API."""

    model_cls = models.RDMRecordMetadata

    index = IndexField(
        "rdmrecords-records-record-v7.0.0", search_alias="rdmrecords-records"
    )

    files = FilesField(
        store=False,
        dump=True,
        # Don't dump files if record is public and files restricted.
        dump_entries=lambda record: not (
            record.access.protection.record == Visibility.PUBLIC.value
            and record.access.protection.files == Visibility.RESTRICTED.value
        ),
        file_cls=RDMFileRecord,
        # Don't create
        create=False,
        # Don't delete, we'll manage in the service
        delete=False,
    )

    media_files = FilesField(
        key=MediaFilesAttrConfig["_files_attr_key"],
        bucket_id_attr=MediaFilesAttrConfig["_files_bucket_id_attr_key"],
        bucket_attr=MediaFilesAttrConfig["_files_bucket_attr_key"],
        store=False,
        dump=False,
        file_cls=RDMMediaFileRecord,
        # Don't create
        create=False,
        # Don't delete, we'll manage in the service
        delete=False,
    )

    has_draft = HasDraftCheckField(RDMDraft)

    status = DraftStatus()

    stats = RecordStatisticsField()

    deletion_status = RecordDeletionStatusField()

    tombstone = TombstoneField()

    @classmethod
    def next_latest_published_record_by_parent(cls, parent):
        """Get the next latest published record.

        This method gives back the next published latest record by parent or None if all
        records are deleted i.e `record.deletion_status != 'P'`.

        :param parent: parent record.
        :param excluded_latest: latest record to exclude find next published version
        """
        with db.session.no_autoflush:
            rec_model_query = (
                cls.model_cls.query.filter_by(parent_id=parent.id)
                .filter(
                    cls.model_cls.deletion_status
                    == RecordDeletionStatusEnum.PUBLISHED.value
                )
                .order_by(cls.model_cls.index.desc())
            )
            current_latest_id = cls.get_latest_by_parent(parent, id_only=True)
            if current_latest_id:
                rec_model_query.filter(cls.model_cls.id != current_latest_id)

            rec_model = rec_model_query.first()
            return (
                cls(rec_model.data, model=rec_model, parent=parent)
                if rec_model
                else None
            )

    @classmethod
    def get_latest_published_by_parent(cls, parent):
        """Get the latest published record for the specified parent record.

        It might return None if there is no latest published version i.e not
        published yet or all versions are deleted.
        """
        latest_record = cls.get_latest_by_parent(parent)
        if latest_record.deletion_status != RecordDeletionStatusEnum.PUBLISHED.value:
            return None
        return latest_record

File: /home/samk13/.pyenv/versions/invenio-rdm-records/lib/python3.12/site-packages/invenio_records/api.py

class Record(RecordBase):
    """Define API for metadata creation and manipulation."""

    send_signals = True
    """Class-level attribute to control if signals should be sent."""

    @classmethod
    def create(cls, data, id_=None, **kwargs):
        r"""Create a new record instance and store it in the database.

        #. Send a signal :data:`invenio_records.signals.before_record_insert`
           with the new record as parameter.

        #. Validate the new record data.

        #. Add the new record in the database.

        #. Send a signal :data:`invenio_records.signals.after_record_insert`
           with the new created record as parameter.

        :Keyword Arguments:
          * **format_checker** --
            An instance of the class :class:`jsonschema.FormatChecker`, which
            contains validation rules for formats. See
            :func:`~invenio_records.api.RecordBase.validate` for more details.

          * **validator** --
            A :class:`jsonschema.protocols.Validator` class that will be used
            to validate the record. See
            :func:`~invenio_records.api.RecordBase.validate` for more details.

        :param data: Dict with the record metadata.
        :param id_: Specify a UUID to use for the new record, instead of
                    automatically generated.
        :returns: A new :class:`Record` instance.
        """
        with db.session.begin_nested():
            # For backward compatibility we pop them here.
            format_checker = kwargs.pop("format_checker", None)
            validator = kwargs.pop("validator", None)

            # Create the record and the model
            record = cls(data, model=cls.model_cls(id=id_, data=data), **kwargs)

            if cls.send_signals:
                before_record_insert.send(
                    current_app._get_current_object(), record=record
                )

            # Run pre create extensions
            for e in cls._extensions:
                e.pre_create(record)

            # Validate also encodes the data
            record._validate(
                format_checker=format_checker,
                validator=validator,
                use_model=True,  # use model (already encoded) and didn't change
            )

            db.session.add(record.model)

        if cls.send_signals:
            after_record_insert.send(current_app._get_current_object(), record=record)

        # Run post create extensions
        for e in cls._extensions:
            e.post_create(record)

        return record

    @classmethod
    def get_record(cls, id_, with_deleted=False):
        """Retrieve the record by id.

        Raise a database exception if the record does not exist.

        :param id_: record ID.
        :param with_deleted: If `True` then it includes deleted records.
        :returns: The :class:`Record` instance.
        """
        with db.session.no_autoflush:
            query = cls.model_cls.query.filter_by(id=id_)
            if not with_deleted:
                query = query.filter(cls.model_cls.is_deleted != True)  # noqa
            obj = query.one()
            return cls(obj.data, model=obj)

    @classmethod
    def get_records(cls, ids, with_deleted=False):
        """Retrieve multiple records by id.

        :param ids: List of record IDs.
        :param with_deleted: If `True` then it includes deleted records.
        :returns: A list of :class:`Record` instances.
        """
        with db.session.no_autoflush:
            query = cls.model_cls.query.filter(cls.model_cls.id.in_(ids))
            if not with_deleted:
                query = query.filter(cls.model_cls.is_deleted != True)  # noqa

            return [cls(obj.data, model=obj) for obj in query.all()]

    def patch(self, patch):
        """Patch record metadata.

        :params patch: Dictionary of record metadata.
        :returns: A new :class:`Record` instance.
        """
        warnings.warn(
            "The patch() method is deprecated and will be removed.", DeprecationWarning
        )
        data = apply_patch(dict(self), patch)
        return self.__class__(data, model=self.model)

    def commit(self, format_checker=None, validator=None, **kwargs):
        r"""Store changes of the current record instance in the database.

        #. Send a signal :data:`invenio_records.signals.before_record_update`
           with the current record to be committed as parameter.

        #. Validate the current record data.

        #. Commit the current record in the database.

        #. Send a signal :data:`invenio_records.signals.after_record_update`
            with the committed record as parameter.

        :Keyword Arguments:
          * **format_checker** --
            An instance of the class :class:`jsonschema.FormatChecker`, which
            contains validation rules for formats. See
            :func:`~invenio_records.api.RecordBase.validate` for more details.

          * **validator** --
            A :class:`jsonschema.protocols.Validator` class that will be used
            to validate the record. See
            :func:`~invenio_records.api.RecordBase.validate` for more details.

        :returns: The :class:`Record` instance.
        """
        if self.model is None or self.model.is_deleted:
            raise MissingModelError()

        with db.session.begin_nested():
            if self.send_signals:
                before_record_update.send(
                    current_app._get_current_object(), record=self
                )

            # Run pre commit extensions
            for e in self._extensions:
                e.pre_commit(self, **kwargs)

            # Validate also encodes the data
            json = self._validate(format_checker=format_checker, validator=validator)

            # Thus, we pass the encoded JSON directly to the model to avoid
            # double encoding.
            self.model.json = json
            flag_modified(self.model, "json")

            db.session.merge(self.model)

        if self.send_signals:
            after_record_update.send(current_app._get_current_object(), record=self)

        # Run post commit extensions
        for e in self._extensions:
            e.post_commit(self)

        return self

    def delete(self, force=False):
        """Delete a record.

        If `force` is ``False``, the record is soft-deleted: record data will
        be deleted but the record identifier and the history of the record will
        be kept. This ensures that the same record identifier cannot be used
        twice, and that you can still retrieve its history. If `force` is
        ``True``, then the record is completely deleted from the database.

        #. Send a signal :data:`invenio_records.signals.before_record_delete`
           with the current record as parameter.

        #. Delete or soft-delete the current record.

        #. Send a signal :data:`invenio_records.signals.after_record_delete`
           with the current deleted record as parameter.

        :param force: if ``True``, completely deletes the current record from
               the database, otherwise soft-deletes it.
        :returns: The deleted :class:`Record` instance.
        """
        if self.model is None:
            raise MissingModelError()

        with db.session.begin_nested():
            if self.send_signals:
                before_record_delete.send(
                    current_app._get_current_object(), record=self
                )

            # Run pre delete extensions
            for e in self._extensions:
                e.pre_delete(self, force=force)

            if force:
                db.session.delete(self.model)
            else:
                self.model.is_deleted = True
                db.session.merge(self.model)

        if self.send_signals:
            after_record_delete.send(current_app._get_current_object(), record=self)

        # Run post delete extensions
        for e in self._extensions:
            e.post_delete(self, force=force)

        return self

    def undelete(self):
        """Undelete a soft-deleted record."""
        if self.model is None:
            raise MissingModelError()

        self.model.is_deleted = False

        return self

    def revert(self, revision_id):
        """Revert the record to a specific revision.

        #. Send a signal :data:`invenio_records.signals.before_record_revert`
           with the current record as parameter.

        #. Revert the record to the revision id passed as parameter.

        #. Send a signal :data:`invenio_records.signals.after_record_revert`
           with the reverted record as parameter.

        :param revision_id: Specify the record revision id
        :returns: The :class:`Record` instance corresponding to the revision id
        """
        if self.model is None:
            raise MissingModelError()

        revision = self.revisions[revision_id]

        with db.session.begin_nested():
            if self.send_signals:
                # TODO: arguments to this signal does not make sense.
                # Ought to be both record and revision.
                before_record_revert.send(
                    current_app._get_current_object(), record=self
                )

            for e in self._extensions:
                e.pre_revert(self, revision)

            # Here we explicitly set the json column in order to not
            # encode/decode the json data via the ``data`` property.
            self.model.json = revision.model.json
            flag_modified(self.model, "json")

            db.session.merge(self.model)

        if self.send_signals:
            # TODO: arguments to this signal does not make sense.
            # Ought to be the class being returned just below and should
            # include the revision.
            after_record_revert.send(current_app._get_current_object(), record=self)

        record = self.__class__(self.model.data, model=self.model)

        for e in self._extensions:
            e.post_revert(record, revision)

        return record

    @property
    def revisions(self):
        """Get revisions iterator."""
        if self.model is None:
            raise MissingModelError()

        return RevisionsIterator(self.model)

File: /home/samk13/.pyenv/versions/invenio-rdm-records/lib/python3.12/site-packages/invenio_records/api.py

class RecordBase(dict):
    """Base class for Record and RecordRevision to share common features."""

    model_cls = RecordMetadata
    """SQLAlchemy model class defining which table stores the records."""

    format_checker = None
    """Class-level attribute to specify a default JSONSchema format checker."""

    validator = None
    """Class-level attribute to specify a JSONSchema validator class."""

    dumper = Dumper()
    """Class-level attribute to specify the default data dumper/loader.

    For backward compatibility the dumper used here just produces a deep copy
    of the record.
    """

    enable_jsonref = True
    """Class-level attribute to control if JSONRef replacement is supported."""

    _extensions = []
    """Record extensions registry.

    Allows extensions (like system fields) to be registered on the record.
    """

    def __init__(self, data, model=None, **kwargs):
        """Initialize instance with dictionary data and SQLAlchemy model.

        :param data: Dict with record metadata.
        :param model: :class:`~invenio_records.models.RecordMetadata` instance.
        """
        self.model = model
        for e in self._extensions:
            e.pre_init(self, data, model=model, **kwargs)
        super(RecordBase, self).__init__(data or {})
        for e in self._extensions:
            e.post_init(self, data, model=model, **kwargs)

    @property
    def id(self):
        """Get model identifier."""
        return self.model.id if self.model else None

    @property
    def revision_id(self):
        """Get revision identifier."""
        return self.model.version_id - 1 if self.model else None

    @property
    def created(self):
        """Get creation timestamp."""
        return self.model.created if self.model else None

    @property
    def updated(self):
        """Get last updated timestamp."""
        return self.model.updated if self.model else None

    @property
    def is_deleted(self):
        """Get creation timestamp."""
        return self.model.is_deleted if self.model else None

    def validate(self, format_checker=None, validator=None, **kwargs):
        r"""Validate record according to schema defined in ``$schema`` key.

        :Keyword Arguments:
          * **format_checker** --
            A ``format_checker`` is an instance of class
            :class:`jsonschema.FormatChecker` containing business logic to
            validate arbitrary formats. For example:

            >>> from jsonschema import FormatChecker
            >>> from jsonschema.validators import validate
            >>> checker = FormatChecker()
            >>> checker.checks('foo')(lambda el: el.startswith('foo'))
            <function <lambda> at ...>
            >>> validate('foo', {'format': 'foo'}, format_checker=checker)

            returns ``None``, which means that the validation was successful,
            while

            >>> validate('bar', {'format': 'foo'},
            ...    format_checker=checker)  # doctest: +IGNORE_EXCEPTION_DETAIL
            Traceback (most recent call last):
              ...
            ValidationError: 'bar' is not a 'foo'
              ...

            raises a :class:`jsonschema.exceptions.ValidationError`.

          * **validator** --
            A :class:`jsonschema.protocols.Validator` class used for record
            validation. It will be used as `cls` argument when calling
            :func:`jsonschema.validate`. For example

            >>> from jsonschema.validators import extend, Draft4Validator
            >>> NoRequiredValidator = extend(
            ...     Draft4Validator,
            ...     validators={'required': lambda v, r, i, s: None}
            ... )
            >>> schema = {
            ...     'type': 'object',
            ...     'properties': {
            ...         'name': { 'type': 'string' },
            ...         'email': { 'type': 'string' },
            ...         'address': {'type': 'string' },
            ...         'telephone': { 'type': 'string' }
            ...     },
            ...     'required': ['name', 'email']
            ... }
            >>> from jsonschema.validators import validate
            >>> validate({}, schema, NoRequiredValidator)

            returns ``None``, which means that the validation was successful,
            while

            >>> validate({}, schema)  # doctest: +IGNORE_EXCEPTION_DETAIL
            Traceback (most recent call last):
            ...
            ValidationError: 'name' is a required property
            ...

            raises a :class:`jsonschema.exceptions.ValidationError`.
        """
        # 1) For backward compatibility we do not change the method signature
        # (i.e. return a ``None`` value on successful validation).
        # The actual implementation of the validation method is implemented
        # below in _validate() which is also the one used internally to avoid
        # double encoding of the dict to JSON.
        # 2) We ignore **kwargs (but keep it for backward compatibility) as
        # the jsonschema.protocols.Validator only takes the two keyword
        # arguments formater_checker and cls (i.e. validator).
        self._validate(format_checker=format_checker, validator=validator)

    def _validate(self, format_checker=None, validator=None, use_model=False):
        """Implementation of the JSONSchema validation."""
        # Use the encoder to transform Python dictionary into JSON document
        # prior to validation unless we explicitly ask to use the already
        # encoded JSON in the model.
        if use_model:
            json = self.model.json
        else:
            json = self.model_cls.encode(dict(self))

        if "$schema" in self and self["$schema"] is not None:
            # Validate (an error will raise an exception)
            _records_state.validate(
                json,
                self["$schema"],
                # Use defaults of class if not specified by user.
                format_checker=format_checker or self.format_checker,
                cls=validator or self.validator,
            )

        # Return encoded data, so we don't have to double encode.
        return json

    def replace_refs(self):
        """Replace the ``$ref`` keys within the JSON."""
        if self.enable_jsonref:
            return _records_state.replace_refs(self)
        else:
            return self

    def clear_none(self, key=None):
        """Helper method to clear None, empty dict and list values.

        Modifications are done in place.
        """
        clear_none(dict_lookup(self, key) if key else self)

    def dumps(self, dumper=None):
        """Make a dump of the record (defaults to a deep copy of the dict).

        This method produces a version of a record that can be persisted on
        storage such as the database, search or other mediums depending
        on the dumper class used.

        :param dumper: Dumper to use when dumping the record.
        :returns: A ``dict``.
        """
        dumper = dumper or self.dumper

        data = {}

        # Run pre dump extensions
        for e in self._extensions:
            pre_dump_params = inspect.signature(e.pre_dump).parameters
            if "data" in pre_dump_params:
                e.pre_dump(self, data, dumper=dumper)
            else:
                # TODO: Remove in v1.6.0 or later
                warnings.warn(
                    "The pre_dump hook must take a positional argument data.",
                    DeprecationWarning,
                )
                e.pre_dump(self, dumper=dumper)

        dump_params = inspect.signature(dumper.dump).parameters
        if "data" in dump_params:
            # Execute the dump - for backwards compatibility we use the default
            # dumper which returns a deepcopy.
            data = dumper.dump(self, data)
        else:
            # TODO: Remove in v1.6.0 or later
            warnings.warn(
                "The dumper.dump() must take a positional argument data.",
                DeprecationWarning,
            )
            data = dumper.dump(self)

        for e in self._extensions:
            e.post_dump(self, data, dumper=dumper)

        return data

    @classmethod
    def loads(cls, data, loader=None):
        """Load a record dump.

        :param loader: Loader class to use when loading the record.
        :returns: A new :class:`Record` instance.
        """
        # The method is named with in plural to align with dumps (which is
        # named with s even if it should probably have been called "dump"
        # instead.
        loader = loader or cls.dumper

        data = deepcopy(data)  # avoid mutating the original object
        # Run pre load extensions
        for e in cls._extensions:
            e.pre_load(data, loader=loader)

        record = loader.load(data, cls)

        # Run post load extensions
        for e in cls._extensions:
            post_load_params = inspect.signature(e.post_load).parameters
            if "data" in post_load_params:
                e.post_load(record, data, loader=loader)
            else:
                # TODO: Remove in v1.6.0 or later
                warnings.warn(
                    "The post_load hook must take a positional argument data.",
                    DeprecationWarning,
                )
                e.post_load(record, loader=loader)

        return record

File: /home/samk13/INVENIO/issues/invenio-rdm-records/invenio_rdm_records/resources/serializers/schemas.py

class CommonFieldsMixin:
    """Common fields serialization."""

    def get_doi(self, obj):
        """Get DOI."""
        if "doi" in obj["pids"]:
            return obj["pids"]["doi"]["identifier"]

        for identifier in obj["metadata"].get("identifiers", []):
            if identifier["scheme"] == "doi":
                return identifier["identifier"]

        return missing

    def get_locations(self, obj):
        """Get locations."""
        locations = []

        access_location = obj["metadata"].get("locations", {})

        if not access_location:
            return missing

        for location in access_location.get("features", []):
            location_string = ""

            place = location.get("place")
            description = location.get("description")
            if place:
                location_string += f"name={place}; "
            if description:
                location_string += f"description={description}"
            geometry = location.get("geometry")
            if geometry:
                geo_type = geometry["type"]
                if geo_type == "Point":
                    coords = geometry["coordinates"]
                    location_string += f"; lat={coords[0]}; lon={coords[1]}"

            locations.append(location_string)

        return locations

    def get_titles(self, obj):
        """Get titles."""
        title = py_.get(obj, "metadata.title")
        return [title] if title else missing

    def get_identifiers(self, obj):
        """Get identifiers."""
        items = []
        items.extend(i["identifier"] for i in obj["metadata"].get("identifiers", []))
        items.extend(p["identifier"] for p in obj.get("pids", {}).values())

        return items or missing

    def get_creators(self, obj):
        """Get creators."""
        return [
            c["person_or_org"]["name"] for c in obj["metadata"].get("creators", [])
        ] or missing

    def get_publishers(self, obj):
        """Get publishers."""
        publisher = obj["metadata"].get("publisher")
        if publisher:
            return [publisher]
        return missing

    def get_contributors(self, obj):
        """Get contributors."""
        return [
            c["person_or_org"]["name"] for c in obj["metadata"].get("contributors", [])
        ] or missing

File: /home/samk13/INVENIO/issues/invenio-rdm-records/invenio_rdm_records/records/api.py

def get_latest_published_by_parent(cls, parent):
        """Get the latest published record for the specified parent record.

        It might return None if there is no latest published version i.e not
        published yet or all versions are deleted.
        """
        latest_record = cls.get_latest_by_parent(parent)
        if latest_record.deletion_status != RecordDeletionStatusEnum.PUBLISHED.value:
            return None
        return latest_record

File: /home/samk13/INVENIO/issues/invenio-rdm-records/invenio_rdm_records/records/api.py

class RDMMediaFileRecord(FileRecord):
    """Example record file API."""

    model_cls = models.RDMMediaFileRecordMetadata
    record_cls = None  # defined below

    # Stores record files processor information
    processor = DictField(clear_none=True, create_if_missing=True)

File: /home/samk13/.pyenv/versions/invenio-rdm-records/lib/python3.12/site-packages/invenio_records_resources/records/api.py

class FileRecord(RecordBase, SystemFieldsMixin):
    """Base class for a record describing a file."""

    @classmethod
    def get_by_key(cls, record_id, key):
        """Get a record file by record ID and filename/key."""
        with db.session.no_autoflush:
            obj = cls.model_cls.query.filter(
                cls.record_id == record_id, cls.key == key
            ).one_or_none()
            if obj:
                return cls(obj.data, model=obj)

    @classmethod
    def list_by_record(cls, record_id, with_deleted=False):
        """List all record files by record ID."""
        with db.session.no_autoflush:
            query = cls.model_cls.query.filter(cls.model_cls.record_id == record_id)

            if not with_deleted:
                query = query.filter(cls.model_cls.is_deleted != True)

            for obj in query:
                yield cls(obj.data, model=obj)

    @property
    def file(self):
        """File wrapper object."""
        if self.object_version:
            return File(object_model=self.object_version)

    @contextmanager
    def open_stream(self, mode):
        """Get a file stream for a given file record."""
        fp = self.object_version.file.storage().open(mode)
        try:
            yield fp
        finally:
            fp.close()

    def get_stream(self, mode):
        """Get a file stream for a given file record.

        It is up to the caller to close the steam.
        """
        return self.object_version.file.storage().open(mode)

    @property
    def record(self):
        """Get the file's record."""
        return self.record_cls(self._record.data, model=self._record)

    @classmethod
    def remove_all(cls, record_id):
        """Hard delete record's file instances."""
        record_files = cls.model_cls.query.filter(cls.model_cls.record_id == record_id)
        record_files.delete(synchronize_session=False)

    send_signals = False
    enable_jsonref = False

    #: Default model class used by the record API (specify in subclass).
    model_cls = None

    #: Record API class.
    record_cls = None

    #: Default dumper (which happens to also be used for indexing).
    dumper = SearchDumper()

    #: Metadata system field.
    metadata = DictField(clear_none=True, create_if_missing=True)

    #: Access system field
    access = FileAccessField()

    key = ModelField()
    object_version_id = ModelField()
    object_version = ModelField(dump=False)
    record_id = ModelField()
    _record = ModelField("record", dump=False)

    def __repr__(
        self,
    ):
        """Represenation string for the record file."""
        return f"<{type(self).__name__}({self.key}, {self.metadata})"

File: /home/samk13/.pyenv/versions/invenio-rdm-records/lib/python3.12/site-packages/invenio_records/systemfields/base.py

class SystemFieldsMixin(metaclass=SystemFieldsMeta):
    """Mixin class for records that add system fields capabilities.

    This class is primarily syntax sugar for being able to do::

      class MyRecord(Record, SystemsFieldsMixin):
          pass

    instead of::

      class MyRecord(Record, metaclass=SystemFieldsMeta):
          pass

    There are subtle differences though between the two above methods. Mainly
    which classes will execute the ``__new__()`` method on the metaclass.
    """

